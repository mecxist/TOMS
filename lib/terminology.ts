import { prisma as db } from './db'
import { TalentModel } from '@prisma/client'

/**
 * Default terminology maps by talent model
 */
export const DEFAULT_TERMINOLOGY: Record<TalentModel, Record<string, string>> = {
  EMPLOYMENT: {
    application: 'Application',
    candidate: 'Candidate',
    applied: 'Applied',
    applicationStatus: 'Application Status',
    offer: 'Offer',
    offerSent: 'Offer Sent',
    hired: 'Hired',
    accepted: 'Accepted',
    rejected: 'Rejected',
    withdrawn: 'Withdrawn',
    employee: 'Employee',
    candidates: 'Candidates',
    hire: 'Hire',
    hiringManager: 'Hiring Manager',
    recruiter: 'Recruiter',
    salary: 'Salary',
    payroll: 'Payroll',
    payrollRun: 'Payroll Run',
    hourlyRate: 'Hourly Rate',
    paid: 'Paid',
    wage: 'Wage',
    timesheet: 'Timesheet',
    timeEntry: 'Time Entry',
    hoursWorked: 'Hours Worked',
    billableHours: 'Billable Hours',
    overtime: 'Overtime',
    project: 'Project',
    assignment: 'Assignment',
    assigned: 'Assigned',
    projectManager: 'Project Manager',
    requisition: 'Requisition',
    openPosition: 'Open Position',
    onboarding: 'Onboarding',
    onboardingTask: 'Onboarding Task',
    contract: 'Contract',
    w9OrW4: 'W9/W4',
    backgroundCheck: 'Background Check',
    training: 'Training',
    status: 'Status',
    pipeline: 'Pipeline',
    stage: 'Stage',
    active: 'Active',
    completed: 'Completed',
    cancelled: 'Cancelled',
    onHold: 'On Hold',
    interview: 'Interview',
    interviewer: 'Interviewer',
    assessment: 'Assessment',
    skillAssessment: 'Skill Assessment',
    feedback: 'Feedback',
    availability: 'Availability',
    availabilitySlot: 'Availability Slot',
    schedule: 'Schedule',
    shift: 'Shift',
    match: 'Match',
    matchScore: 'Match Score',
    shortlisted: 'Shortlisted',
    screening: 'Screening',
    admin: 'Admin',
    settings: 'Settings',
    dashboard: 'Dashboard',
    profile: 'Profile',
  },
  CONTINGENT_WORKFORCE: {
    application: 'Application',
    candidate: 'Talent',
    applied: 'Submitted',
    applicationStatus: 'Application Status',
    offer: 'Invitation',
    offerSent: 'Invitation Sent',
    hired: 'Assigned',
    accepted: 'Confirmed',
    rejected: 'Not Selected',
    withdrawn: 'Cancelled',
    employee: 'Talent',
    candidates: 'Talent Pool',
    hire: 'Assign',
    hiringManager: 'Coordinator',
    recruiter: 'Talent Coordinator',
    salary: 'Rate',
    payroll: 'Payment',
    payrollRun: 'Payment Batch',
    hourlyRate: 'Rate',
    paid: 'Compensated',
    wage: 'Rate',
    timesheet: 'Time Log',
    timeEntry: 'Log Entry',
    hoursWorked: 'Hours Logged',
    billableHours: 'Billable Time',
    overtime: 'Extra Hours',
    project: 'Engagement',
    assignment: 'Assignment',
    assigned: 'Engaged',
    projectManager: 'Engagement Manager',
    requisition: 'Opening',
    openPosition: 'Available Opportunity',
    onboarding: 'Setup',
    onboardingTask: 'Setup Task',
    contract: 'Agreement',
    w9OrW4: 'Tax Forms',
    backgroundCheck: 'Verification',
    training: 'Orientation',
    status: 'Status',
    pipeline: 'Workflow',
    stage: 'Phase',
    active: 'Current',
    completed: 'Finished',
    cancelled: 'Terminated',
    onHold: 'Paused',
    interview: 'Meeting',
    interviewer: 'Assessor',
    assessment: 'Evaluation',
    skillAssessment: 'Skills Check',
    feedback: 'Notes',
    availability: 'Schedule',
    availabilitySlot: 'Time Slot',
    schedule: 'Calendar',
    shift: 'Session',
    match: 'Recommendation',
    matchScore: 'Fit Score',
    shortlisted: 'Selected',
    screening: 'Review',
    admin: 'Admin',
    settings: 'Settings',
    dashboard: 'Dashboard',
    profile: 'Profile',
  },
  VOLUNTEER: {
    application: 'Inquiry',
    candidate: 'Member',
    applied: 'Registered',
    applicationStatus: 'Engagement Status',
    offer: 'Opportunity',
    offerSent: 'Opportunity Extended',
    hired: 'Joined',
    accepted: 'Confirmed',
    rejected: 'Not Moving Forward',
    withdrawn: 'Opted Out',
    employee: 'Volunteer',
    candidates: 'Members',
    hire: 'Welcome',
    hiringManager: 'Coordinator',
    recruiter: 'Coordinator',
    salary: 'Stipend',
    payroll: 'Compensation',
    payrollRun: 'Disbursement',
    hourlyRate: 'Stipend Rate',
    paid: 'Compensated',
    wage: 'Stipend',
    timesheet: 'Contribution Log',
    timeEntry: 'Contribution Entry',
    hoursWorked: 'Time Contributed',
    billableHours: 'Contributed Hours',
    overtime: 'Additional Time',
    project: 'Initiative',
    assignment: 'Role',
    assigned: 'Placed',
    projectManager: 'Lead',
    requisition: 'Opportunity',
    openPosition: 'Available Role',
    onboarding: 'Orientation',
    onboardingTask: 'Orientation Task',
    contract: 'Commitment',
    w9OrW4: 'Tax Information',
    backgroundCheck: 'Screening',
    training: 'Learning',
    status: 'Status',
    pipeline: 'Journey',
    stage: 'Milestone',
    active: 'Ongoing',
    completed: 'Done',
    cancelled: 'Ended',
    onHold: 'Waiting',
    interview: 'Conversation',
    interviewer: 'Reviewer',
    assessment: 'Screening',
    skillAssessment: 'Competency Review',
    feedback: 'Comments',
    availability: 'Capacity',
    availabilitySlot: 'Available Time',
    schedule: 'Plan',
    shift: 'Period',
    match: 'Suggestion',
    matchScore: 'Compatibility Score',
    shortlisted: 'Qualified',
    screening: 'Evaluation',
    admin: 'Administrator',
    settings: 'Preferences',
    dashboard: 'Overview',
    profile: 'Account',
  },
  HYBRID: {
    // Uses EMPLOYMENT defaults but allows per-talent-type customization
    application: 'Application',
    candidate: 'Candidate',
    applied: 'Applied',
    applicationStatus: 'Application Status',
    offer: 'Offer',
    offerSent: 'Offer Sent',
    hired: 'Hired',
    accepted: 'Accepted',
    rejected: 'Rejected',
    withdrawn: 'Withdrawn',
    employee: 'Employee',
    candidates: 'Candidates',
    hire: 'Hire',
    hiringManager: 'Hiring Manager',
    recruiter: 'Recruiter',
    salary: 'Salary',
    payroll: 'Payroll',
    payrollRun: 'Payroll Run',
    hourlyRate: 'Hourly Rate',
    paid: 'Paid',
    wage: 'Wage',
    timesheet: 'Timesheet',
    timeEntry: 'Time Entry',
    hoursWorked: 'Hours Worked',
    billableHours: 'Billable Hours',
    overtime: 'Overtime',
    project: 'Project',
    assignment: 'Assignment',
    assigned: 'Assigned',
    projectManager: 'Project Manager',
    requisition: 'Requisition',
    openPosition: 'Open Position',
    onboarding: 'Onboarding',
    onboardingTask: 'Onboarding Task',
    contract: 'Contract',
    w9OrW4: 'W9/W4',
    backgroundCheck: 'Background Check',
    training: 'Training',
    status: 'Status',
    pipeline: 'Pipeline',
    stage: 'Stage',
    active: 'Active',
    completed: 'Completed',
    cancelled: 'Cancelled',
    onHold: 'On Hold',
    interview: 'Interview',
    interviewer: 'Interviewer',
    assessment: 'Assessment',
    skillAssessment: 'Skill Assessment',
    feedback: 'Feedback',
    availability: 'Availability',
    availabilitySlot: 'Availability Slot',
    schedule: 'Schedule',
    shift: 'Shift',
    match: 'Match',
    matchScore: 'Match Score',
    shortlisted: 'Shortlisted',
    screening: 'Screening',
    admin: 'Admin',
    settings: 'Settings',
    dashboard: 'Dashboard',
    profile: 'Profile',
  },
}

/**
 * Get terminology for an organization
 */
export async function getTerminology(orgId: string): Promise<Record<string, string>> {
  const org = await db.organization.findUnique({
    where: { id: orgId },
    select: {
      talentModel: true,
      terminology: true,
    },
  })

  if (!org) {
    throw new Error('Organization not found')
  }

  const defaults = DEFAULT_TERMINOLOGY[org.talentModel]
  const custom = (org.terminology as Record<string, string>) || {}

  // Merge defaults with custom terminology
  return { ...defaults, ...custom }
}

/**
 * Get a single term with fallback
 */
export async function getTerm(
  key: string,
  orgId: string
): Promise<string> {
  const terminology = await getTerminology(orgId)
  return terminology[key] || key
}

/**
 * Update terminology for an organization
 */
export async function updateTerminology(
  orgId: string,
  terminology: Record<string, string>
) {
  return db.organization.update({
    where: { id: orgId },
    data: {
      terminology,
    },
  })
}

/**
 * Get default terminology for a talent model
 */
export function getDefaultTerminology(model: TalentModel): Record<string, string> {
  return DEFAULT_TERMINOLOGY[model]
}
